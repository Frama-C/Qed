\section{Logic Modulo}
\label{logic}

We present here the fundamental logic system behind \Qed. It is a
simply typed logic system, using natural signed integers $z\in\Z$,
real numbers $r\in\R$ and user-defined abstract datatypes as ground
terms. We first introduce the (abstract) syntax for the language, and
then its typing rules.

\subsection{The language}

To simplify notations, we do not separate \emph{predicates} from
\emph{terms} at the syntax level, but at the typing level.  Actually,
such a design also simplifies the implementation of normalization and
maximal sharing and eliminates the redundancy between boolean and
predicate operators. 

We denote $\kappa$ the category of terms, which consists of type
$\prop$ for predicates, and $\tau$ for terms. We classically restrict
existential and universal quantification to terms. We denote $\true$
and $\false$ the overloaded truth values of type $\bool$ and $\prop$.

Types also include polymorphic abstract data types, that we call \emph{sorts} and denote $s\in{\cal S}$. For instance, we write $\mathtt{list}(\Z)$ for lists over integers.

Terms can be constructed by application of functions. Each function $f\in\cal F$ is associated to a \emph{signature} $\sem{f}$ which is a partial application from $\tau^*$ to $\tau$. Variables are denoted $x\in\cal X$.

The complete logical language is depicted on figure~\ref{logic-lang}.

\begin{figure}[tp]
  \[
  \begin{array}{|c|}
  \hline\\
  \begin{bnf}
    \kappa &::=& \prop \;|\;\tau \\
    \tau &::=& \\ 
      &|& \bool \\
      &|& \Z \\
      &|& \R \\
      &|& s(\tau^*) \\
    \\
    X &::=& <a:\tau>
  \end{bnf}
  \quad
  \begin{bnf}
    t &::=& \\
    &|& x\in\X \\
    &|& \true \,|\, \false \\
    &|& z\in\Z \,|\, r\in\R \\
    &|& f(t^*) \\
    &|& t \;\mathtt{binop}\; t \\
    &|& \mathtt{unop}\;t \\
    &|& \Pi x.\,t \\
  \end{bnf}
  \\\\
  \begin{bnf}
    \mathtt{binop} &::=&
    \begin{array}[t]{c}
      +, -, \times, \mathtt{div}, \mathtt{mod} \\
      <, \leq, =, \neq \\
      \land, \lor, \limply
    \end{array} \\
    \mathtt{unop} &::=& -, \lnot \\
        \Pi &::=& \forall,\exists,\lambda
  \end{bnf}
  \\
  \\
  \hline
  \end{array}
  \]
  \caption{Types and Terms}
  \label{logic-lang}
\end{figure}

\subsection{Well formed terms}

Terms must be correctly typed in a very standard way. Boolean values can be promoted to propositions, and logical connectors are overloaded over booleans and propositions. Arithmetic operators are overloaded on $\Z$ and $\R$ with promotion from integer to real when necessary. This induces a partial order $(\sqsubseteq)$ over types, and we denote $(\sqcup)$ the associated least upper bound when it is defined:
\[
\begin{array}{ccc}
    \bool\sqsubseteq\prop & 
    \Z\sqsubseteq\R  \\
    \bool\sqcup\prop = \prop &
    \Z\sqcup\R = \R
\end{array}
\]

Partial order over arithmetic types is \emph{not} lifted to polymorphic datatypes, since it would induce a kind of recursive transformation to promote sparse integers into real, which can be difficult to define for arbitrary types.

\begin{figure}[p]
  \[
  \TODO
  \]
  \caption{Typing Rules for Terms}
  \label{typing-terms}
\end{figure}
